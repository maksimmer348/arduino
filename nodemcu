--nodemcu--

D9, D10 — UART
D1, D2 — I²C/TWI
D5–D8 — SPI
D1–D10 — выходы с ШИМ (PWM)
A0 — аналоговый вход с АЦП
==

--
void setup() {}
Функция, содержимое которой выполняется один раз при запуске микроконтроллера. Подробнее – https://alexgyver.ru/lessons/syntax/
==

--
void loop() {}
Функция, содержимое которой выполняется (или пытается выполняться) “по кругу” на протяжении всего времени работы МК. Подробнее –https://alexgyver.ru/lessons/syntax/
==

--
#include <Name.h> 
#include "Name.h" 
похволяет подключать допольнитмельные билиотеки с кодом.
"" - в этом случае компиляотр ищет сперва в папке со скетчем *.ino,а потом в папке с библиотеками. 
<> - ищет файл только в папке с библиотеками
==

--
#define NAME value
директива дающая препроцессору после комплияции заменить указаное название NAME на указаное значение value.
такой способ НЕ РАСХОДУЕТ оперативную память процессора.
#define позволяет делать макрофонкции типа #define sq(x) ((x)*(x)) => SQR(2) => 4
==

--
#if, #elif, #else, #endif
условная комплияция директивы препроцессору - включают или выключают участки кода по условию

#define T 1//определяем Т как 1 

#if (T == 1)//если Т 1
#define A 10//определяем А как 10
#endif (T == 2)//если Т 2
#define A 20//определяем А как 20
#else//если Т имеет иное значение 
#define A 30//определяем А как 30
#endif//конец условия
-
при помощи этого можно собирать и настраивать сложжные проекты с например библиотеками подключаемыми по суловию

#define T 1

void setup()
{
	#if (T == 1)//если параметру Т установить 1 то будет подключеня библиотека Serial 
	Serial.begin(9600);
	Serial.println("Hello");
	#endif
}

подробнее здесь https://alexgyver.ru/lessons/conditions/
==

--
#ifdef, #ifndef
так же позволяют включать или исключать участки кода по условию: indef определенно ли, ifndef не определенно ли? 

#define T 

#ifdef T
#define A 20//если Т определено выведет А как 20(в данном примере выведет это тк Т ОПРЕДЕЛЕН)
#else
#define A 10//в ином случае выведет А как 10
#endif
#ifndef E
#define A 0//если E определено выведет А как 0 (в данном примере выведет это тк Е НЕ ОПРЕДЕЛЕН)
#endif
==

--
return
Оператор прерывания функции, он же оператор возврата значения из функции
==

--
if, else if, else
Оператор сравнения
==

--
? 
тернарный (логика) ? правда : ложь.

int с = (a > b) ? 10 : -20;// если a > b, то с = 10. Если нет, то с = -20
==

--
switch.. case

switch (val) {
  case 1:
    // выполнить, если val == 1
    break;
  case 2:
    // выполнить, если val == 2
    break;
  default:
    // выполнить, если val ни 1 ни 2
    // default опционален
    break;
}
-
switch (val) {
  case 1:
  case 2:
  case 3:
  case 4:
    // выполнить, если val == 1, 2, 3 или 4
    break;
  case 5:
    // выполнить, если val == 5
    break;
}
==

--
for
Цикл – “счётчик”. for (инициализация; условие; инкремент). 

for (int i = 0; i < 10; i++) {
  a = i;    // а примет значения от 0 до 9 на каждой итерации
  Serial.println(a);    // вывод в порт
}
-
for (;;); //бесконечный цикл
==

--
while, 
 Цикл с предусловием.

while (a < b)//если до входа в while !(a<b) в while код не войдет
{
  // выполняется, пока a меньше b
}
==

--
do.. while
цикл с постусловием
do //даже если до входа в while !(a<b) одна итерация кода выполнится пока не дойдет до while
//если к тому времени (a<b) то цикл продолжится пока (a<b)
{
  // выполняется, пока a меньше b
} while (a < b);
==

--
continue
Пропускает все оставшиеся в теле цикла действия и переходит к следующей итерации
==

--
break
Выходит из цикла
==

--
Составные операторы(которые незнаю)

a %= 10;// прибавить остаток от деления. a = a + a % 10
a &= b;//составное битовое И. a = a & b
a ^= b;//составное исключающее  ИЛИ. a = a ^ b
a |= b;//составное ИЛИ. a = a | b
==

--
битовые операции

& битовое И
<< битовый сдвиг влево
>> битовый сдвиг вправо
^ битовое исключающее ИЛИ (аналогичный оператор – xor)
| битовое ИЛИ
~ битовое НЕ

https://alexgyver.ru/lessons/bitmath/
==

--
, 
заптяая тое опреатор помимо стандартных пречислений она может 
выполнять последоватевтальность действий(сделать это и это)
// объявить a и b и дать им значения
int a = 5, b = 10;
-
a = (b = 3, ++b); //а ==4
-
for(byte i = 0, j = 0; i <10; i++, j +=2)//обьявить i и j, i+1 а j+2
{
	//тут i изменяется от 0 до 9 
	//тут j меняется от 0 до 18
}
==

--
&, *, ->
указатели и ссылки
& возвращает адрес данных в памяти(адрес первого блока)
* возвращает значение по указаному адресу
-> оператор косвенного обращения к членам и методам(для указателей на сруктуры и классы).
явлляется которкой записью консрукции через указатель a->b => (*a).b

подробнее https://alexgyver.ru/lessons/bitmath/
==

битовые операции
--
& битовое И
<< битовый сдвиг влево
>> битовый сдвиг вправо
^ битовое исключающее ИЛИ (xor)
| битовое ИЛИ
~ битовове НЕ
подробнее https://alexgyver.ru/lessons/bitmath/
==

----
работа с даными перменные(неизсветные мне)

--
typedef
псеввдоним или переопределение типа(без создания нового типа), typedef type name; где name создать новый тип данных, на основе типа type.

typedef byte color;//иджентичен типа byte, те 0-255

color R,G,B//теперь можно создавть такие переменные это как байт только называется по иному, чтобы мне можно было понять что это именно цвет а не байт
==

--
структура
стандартная шутка составноей тип разнотипных данных  struct ярлык {...};

struct main
{
	int i = 1;
	int g ;
};
-
Ярлык (main) будет являться новым типом данных, и, используя этот ярлык, можно объявлять уже непосредственно саму структуру:

main myStruct;  // объявить одну структуру

myStruct.i = 12;..
-
можно обьбявит структуру без ярлыка
struct 
{
	int i = 1;
	int g ;
}kek;// и сразу создаём структуру kek

kek.i = 12;...
==

--
enum
обычнопе перечисление работает так же 
имена в enum для программы являются числами, начиная с 0 и далее по порядку увеличиваясь на 1
или можно приравнять число напрямую 
enum {
  NORMAL,//0
  WAITING,//1
  SETTINGS_1 = 102,//напрямую
  SETTINGS_2,//103
-
enum {
  NORMAL,//0
  WAITING,//1
  SETTINGS_1,//2
  SETTINGS_2,
  CALIBRATION,
  ERROR_MODE,
} modes;

 modes = CALIBRATION;  // присваивание значения

 if (modes == CALIBRATION) {...}
==

--
class 
иерархия такая класс => обьект => свойства и методы 

подбробнее https://alexgyver.ru/lessons/class/
==

--
[]  массивы

int myPins[] = {2, 4, 8, 3, 6};
int i = myPins[0]; // i==2
myPins[0] = 12; 
i = myPins[0]; //i == 12
==

--
String 
работа со строками 
String string6 = String(20, DEC);// конвертируем из числа с указанием базиса (десятичный)
String string7 = String(45, HEX);// конвертируем из числа с указанием базиса (16-ричный)
String string8 = String(255, BIN);// конвертируем из числа с указанием базиса (двоичный)
String string9 = String(5.698, 3);// из float с указанием количества знаков после запятой (тут 3)
-
//можно формировать название из кусочков
#define NAME "X"
#define TYPE "-log"
#define EXT ".txt"

String fileName = String(NAME) + TYPE + EXT;
-
charAt()

String string0 = "Hello";   
int index =2;
char ch = string0.charAt(index);//возвращает элемент строки под именем index или так mySting[index], s == 'l'
-
setCharAt()

String string0 = "Hello String";   
int index =0;
char val = 's';
String str = string0.charAt(index,val);//записывает в строку string0 символ на позицию index, str == sello











































